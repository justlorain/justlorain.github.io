[{"categories":["BINARY WEB ECO"],"content":"Introduction As shown in the title, DREAMEMO is a distributed cache with out-of-the-box, high-scalability, modular-design features.The groupcache implementation is referenced, and re-structured, specific module differentiation is as follows: The main modules will be introduced in detail in the design module. ","date":"2023-05-05","objectID":"/dreamemo/:1:0","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Quick Start ","date":"2023-05-05","objectID":"/dreamemo/:2:0","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Install Execute following command to install DREAMEMO: go get github.com/B1NARY-GR0UP/dreamemo ","date":"2023-05-05","objectID":"/dreamemo/:2:1","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Run with standalone mode DREAMEMO provides a function dream.StandAlone used default configuration to help user to start in standalone mode swiftly. All you need to do is configure the source.Getter of the corresponding data source. package main import ( \"context\" \"fmt\" \"net/http\" \"github.com/B1NARY-GR0UP/dreamemo/common/constant\" \"github.com/B1NARY-GR0UP/dreamemo/dream\" \"github.com/B1NARY-GR0UP/dreamemo/guidance\" \"github.com/B1NARY-GR0UP/dreamemo/source\" log \"github.com/B1NARY-GR0UP/inquisitor/core\" \"github.com/B1NARY-GR0UP/piano/core\" \"github.com/B1NARY-GR0UP/piano/core/bin\" ) var db = map[string]string{ \"binary\": \"dreamemo\", \"hello\": \"world\", \"ping\": \"pong\", } func getFromDB(_ context.Context, key string) ([]byte, error) { log.Info(\"Get from DB\") if v, ok := db[key]; ok { return []byte(v), nil } return nil, fmt.Errorf(\"key %v is not exist\", key) } // go run . // curl localhost:8080/hello?key=ping func main() { dream.StandAlone(source.GetterFunc(getFromDB)) p := bin.Default(core.WithHostAddr(\":8080\")) p.GET(\"/hello\", func(ctx context.Context, pk *core.PianoKey) { key := pk.Query(\"key\") g := guidance.GetGroup(constant.DefaultGroupName) value, _ := g.Get(ctx, key) pk.JSON(http.StatusOK, core.M{ key: value.String(), }) }) p.Play() } Here in the form of a map simulation data source database, and use PIANO HTTP framework as a front-end server instead of using other HTTP frameworks like Hertz, Gin, etc. You can start the server with go run . and then simply visit the URL to retrieve the key. go run . curl localhost:8080/hello?key=ping ","date":"2023-05-05","objectID":"/dreamemo/:2:2","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Run with cluster mode DREAMEMO also provides a dream.Cluster function that runs in Cluster mode using the default configuration. All you need to do is configure the address of the corresponding cluster node and the data source. package main import ( \"context\" \"fmt\" \"net/http\" \"github.com/B1NARY-GR0UP/dreamemo/common/constant\" \"github.com/B1NARY-GR0UP/dreamemo/common/util\" \"github.com/B1NARY-GR0UP/dreamemo/dream\" \"github.com/B1NARY-GR0UP/dreamemo/guidance\" \"github.com/B1NARY-GR0UP/dreamemo/source\" log \"github.com/B1NARY-GR0UP/inquisitor/core\" \"github.com/B1NARY-GR0UP/piano/core\" \"github.com/B1NARY-GR0UP/piano/core/bin\" ) var db = map[string]string{ \"binary\": \"dreamemo\", \"hello\": \"world\", \"ping\": \"pong\", } func getFromDB(_ context.Context, key string) ([]byte, error) { log.Info(\"Get from DB\") if v, ok := db[key]; ok { return []byte(v), nil } return nil, fmt.Errorf(\"key %v is not exist\", key) } // go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api // go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 // go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 // curl localhost:8080/hello?key=ping func main() { addrs, api := util.ParseFlags() e := dream.Cluster(source.GetterFunc(getFromDB), addrs...) if api { go func() { p := bin.Default(core.WithHostAddr(\":8080\")) p.GET(\"/hello\", func(ctx context.Context, pk *core.PianoKey) { key := pk.Query(\"key\") g := guidance.GetGroup(constant.DefaultGroupName) value, _ := g.Get(ctx, key) pk.JSON(http.StatusOK, core.M{ key: value.String(), }) }) p.Play() }() } e.Run() } Again, the database data source is simulated as map, and three cache nodes are configured at localhost:7246, localhost:7247 and localhost:7248, the frontend server is configured on port 8080. To retrieve the value of the key, run the following command and visit the URL: go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 curl localhost:8080/hello?key=ping ","date":"2023-05-05","objectID":"/dreamemo/:2:3","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Custom Assemble dream.StandAlone and dream.Cluster functions configured by DREAMEMO were used earlier, here we’ll look at a more customized way of running the assembly. Configure Engine Here we configure the engine, util.ParseFlags is a utility method provided to parse flag arguments. We use app.WithHostAddr to configure the engine to listen to and app.WithThrift0 to use Thrift as the serialization protocol and register other nodes. addrs, api := util.ParseFlags() e := server.NewEngine(app.WithHostAddr(addrs[0]), app.WithThrift0()) e.RegisterInstances(addrs...) Configure cache eliminate strategy Configure LFU l := lfu.NewLFUCore() m := memo.NewMemo(l) Configure cache group We configure the cache group name with guidance.WithGroupName, configure Thrift as the serialization protocol with guidance.WithThrift1, be consistent with the engine, and configure the data source with source.Getter guidance.NewGroup(m, e, guidance.WithGroupName(\"hello\"), guidance.WithThrift1(), guidance.WithGetter(source.GetterFunc(getFromDB))) The complete code is as follows: package main import ( \"context\" \"fmt\" \"net/http\" \"github.com/B1NARY-GR0UP/dreamemo/app\" \"github.com/B1NARY-GR0UP/dreamemo/app/server\" \"github.com/B1NARY-GR0UP/dreamemo/common/util\" \"github.com/B1NARY-GR0UP/dreamemo/guidance\" \"github.com/B1NARY-GR0UP/dreamemo/memo\" \"github.com/B1NARY-GR0UP/dreamemo/source\" \"github.com/B1NARY-GR0UP/dreamemo/strategy/eliminate/lfu\" log \"github.com/B1NARY-GR0UP/inquisitor/core\" \"github.com/B1NARY-GR0UP/piano/core\" \"github.com/B1NARY-GR0UP/piano/core/bin\" ) var db = map[string]string{ \"binary\": \"dreamemo\", \"hello\": \"world\", \"ping\": \"pong\", } func getFromDB(_ context.Context, key string) ([]byte, error) { log.Info(\"Get from DB\") if v, ok := db[key]; ok { return []byte(v), nil } return nil, fmt.Errorf(\"key %v is not exist\", key) } // go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api // go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 // go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 // curl localhost:8080/hello?key=ping func main() { addrs, api := util.ParseFlags() e := server.NewEngine(app.WithHostAddr(addrs[0]), app.WithThrift0()) e.RegisterInstances(addrs...) l := lfu.NewLFUCore() m := memo.NewMemo(l) guidance.NewGroup(m, e, guidance.WithGroupName(\"hello\"), guidance.WithThrift1(), guidance.WithGetter(source.GetterFunc(getFromDB))) if api { go func() { p := bin.Default(core.WithHostAddr(\":8080\")) p.GET(\"/hello\", func(ctx context.Context, pk *core.PianoKey) { key := pk.Query(\"key\") g := guidance.GetGroup(\"hello\") value, _ := g.Get(ctx, key) pk.JSON(http.StatusOK, core.M{ key: value.String(), }) }) p.Play() }() } e.Run() } Run and get the cache value with the following command: go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 curl localhost:8080/hello?key=ping ","date":"2023-05-05","objectID":"/dreamemo/:2:4","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Design ","date":"2023-05-05","objectID":"/dreamemo/:3:0","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Eliminate strategy In terms of cache elimination strategy, DREAMEMO supports LRU and LFU cache elimination algorithms, and users can choose and assemble them by themselves: LRU c := lru.NewLRUCore() LFU c := lfu.NewLFUCore() DREAMEMO also provides an interface for uses to extend other eliminate strategies. Just implement the interface and pass the object to memo.NewMemo as follows: type ICore interface { Add(Key, Value) Get(Key) (Value, bool) Remove(Key) Clear() Name() string } ","date":"2023-05-05","objectID":"/dreamemo/:3:1","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Serialization DREAMEMO supports both Thrift and Protobuf serialization protocols.The default is Protobuf, and to use Thrift, you need to enable Thrift in both the configuration engine and the cache group: e := server.NewEngine(app.WithThrift0()) // engine guidance.NewGroup(m, e, guidance.WithThrift1()) // group ","date":"2023-05-05","objectID":"/dreamemo/:3:2","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Data Source DREAMEMO provides a default configuration to use Redis as a data source: s := redis.NewSource() DREAMEMO also provides an interface to configure more data sources of your own: type Getter interface { Get(ctx context.Context, key string) ([]byte, error) } ","date":"2023-05-05","objectID":"/dreamemo/:3:3","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Consistent Hash DREAMEMO, like groupcache, uses consistent hashing for distributed node selection, while also providing an interface to configure more policies. ","date":"2023-05-05","objectID":"/dreamemo/:3:4","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"TODO DREAMEMO is still very young, and there are many changes that can be made to it. In the future, more node selection algorithms and quick configuration tools will be provided. ","date":"2023-05-05","objectID":"/dreamemo/:4:0","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Summary That’s all for this article. Hope this can help you. I would be appreciate if you could give DREAMEMO a star. If you have any questions, please leave them in the comments or as issues. Thanks for reading. ","date":"2023-05-05","objectID":"/dreamemo/:5:0","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Reference List https://github.com/B1NARY-GR0UP/dreamemo https://github.com/B1NARY-GR0UP/piano https://github.com/golang/groupcache https://github.com/geektutu/7days-golang ","date":"2023-05-05","objectID":"/dreamemo/:6:0","tags":["go","opensource","programming"],"title":"DREAMEMO: An out-of-the-box, high-scalability, modular-design distributed cache","uri":"/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"Introduction Channels are an essential feature of Golang. Skilled use of channels can make concurrent programming feel natural. This article introduces a channel extension PHOS based on Golang native channels. PHOS allows us to perform specific processing on the data sent to the channel. PHOS also has rich configuration options that can be customized according to different requirements. ","date":"2023-05-05","objectID":"/phos/:1:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"What is PHOS? PHOS is a Golang channel extension with internal handlers and diversified options. ","date":"2023-05-05","objectID":"/phos/:2:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"Installation Note: Before installation, make sure your Golang version supports generics (Go \u003e= 1.18). Execute the following command to install PHOS: go get github.com/B1NARY-GR0UP/phos ","date":"2023-05-05","objectID":"/phos/:3:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"Quick Start In the following example, we first define our own built-in processor. Then we create a PHOS instance, add the processor to PHOS’s processor chain, and finally, we can get the result processed by the processor by passing in the data and print it out. That is, BINARY += -PHOS =\u003e BINARY-PHOS. package main import ( \"context\" \"fmt\" \"github.com/B1NARY-GR0UP/phos\" ) func hello(_ context.Context, data string) (string, error) { return data + \"-PHOS\", nil } func main() { ph := phos.New[string]() defer close(ph.In) // Note: You should decide which handlers you want to use once, // otherwise multiple changes to the Handlers slice may cause data race problem ph.Handlers = append(ph.Handlers, hello) ph.In \u003c- \"BINARY\" res := \u003c-ph.Out fmt.Println(res.Data) } ","date":"2023-05-05","objectID":"/phos/:4:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"User Guide ","date":"2023-05-05","objectID":"/phos/:5:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"About Creation PHOS is based on generics. When creating an instance through the phos.New method, we can set the generics to process data of a specific type. When creating an instance, you don’t need to specify the buffer size of the channel, as you would with a regular channel. You can assume that PHOS has an unlimited buffer. PHOS also supports many custom options. We can append these options when creating an instance through phos.New. For example: ph := phos.New[string](phos.WithZero(), phos.WithTimeout(time.Second*5)) More supported options will be listed in tables in later chapters. ","date":"2023-05-05","objectID":"/phos/:5:1","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"About Input and Output PHOS implements data input and output using a read-only and a write-only channel. Input After creating an instance through phos.New, you can input data to PHOS using the public write-only channel In. In the quick start example, we passed in a string to In. Note that the type of the data passed in should be consistent with the generic type used when creating the instance. As we mentioned earlier, you can input data to PHOS almost without limits without specifying the size of the buffer: ph.In \u003c- \"BINARY\" ph.In \u003c- \"Hello\" ph.In \u003c- \"Foo\" ... Output We can also read the data processed by PHOS through the public read-only channel Out. It should be noted that the output value of Out is encapsulated as a Result type: The Data field is the processed result, and its type also matches the generic type of the instance; The OK field is consistent with the second optional variable usage when we usually get data from the channel, which can be used to determine whether data can be read from the channel; Note: When using PHOS, you should not use the second return value of the Out channel but use the OK field of the Result, because the second return value of the Out channel will always be true, and its erroneous use will cause bugs. The Err field will prompt some exceptions that may occur when using PHOS, such as timeout exceptions, internal processor processing exceptions, which will be explained in the following text. // Result PHOS output result type Result[T any] struct { Data T // Note: You should use the OK of Result rather than the second return value of PHOS Out channel OK bool Err *Error } ","date":"2023-05-05","objectID":"/phos/:5:2","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"About internal handlers Built-in processors are one of the most important features of PHOS. By setting one or more built-in processors, PHOS will execute all built-in processors for each input data in order, and we can pass the result processed by the previous processor to the next processor for further processing through the form of return values. A valid processor function signature is as follows: func(ctx context.Context, data T) (T, error) We can construct a processor chain with PHOS’s Handlers public slice field by appending our own custom processors. For example, we have constructed a processor chain with three processors here. Each processor will perform an addition operation on the input data once, and finally, each input data will be returned to us after being added by three (+1 * 3): package main import ( \"context\" \"fmt\" \"github.com/B1NARY-GR0UP/phos\" ) func plusOne(_ context.Context, data int) (int, error) { return data + 1, nil } func main() { ph := phos.New[int]() defer close(ph.In) ph.Handlers = append(ph.Handlers, plusOne, plusOne, plusOne) ph.In \u003c- 1 ph.In \u003c- 2 ph.In \u003c- 3 res1 := \u003c-ph.Out res2 := \u003c-ph.Out res3 := \u003c-ph.Out fmt.Println(res1.Data) // 4 fmt.Println(res2.Data) // 5 fmt.Println(res3.Data) // 6 } ","date":"2023-05-05","objectID":"/phos/:5:3","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"About error handling PHOS wraps and classifies exceptions, mainly into three types: const ( _ ErrorType = iota TimeoutErr HandleErr CtxErr ) Timeout exception The timeout mechanism is a core feature of PHOS. It specifies the maximum processing time for each data in the built-in processor chain. If a timeout occurs, a timeout exception will be triggered. If the timeout exception handler option is not configured, the corresponding initial data will be output, and the timeout exception will be displayed in the Err field of Result; if the timeout exception handler is configured, the data processed by the timeout exception handler will be output. Internal handlers exception If an exception occurs in any of the Internal handlers in the Internal handlers chain, the processor chain will terminate. Whether to return the last processed data or the data processed by the exception handler depends on whether the Internal handlers exception handler is configured. Similarly, the exception will be displayed in the Err field of Result. Context Exception Context exceptions occur when the WithContext option is configured and triggered. At this time, the data processing will be terminated immediately, and whether to return the initial data or the data processed by the exception handler depends on whether the ErrDoneFunc is configured. The exception information will also be displayed in the Err field of Result. Zero Value Option When the zero value option is enabled, a zero value of the corresponding data type will be returned whenever any of the above exceptions occur. This will overwrite the data processing results of the configured timeout exception handler and built-in processor exception handler. ","date":"2023-05-05","objectID":"/phos/:5:4","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"Configuration Option Default Description WithContext context.Background() Set context for PHOS WithZero false Set zero value for return when error happened WithTimeout time.Second * 3 Set timeout for handlers execution WithErrHandleFunc nil Set error handle function for PHOS which will be called when handle error happened WithErrTimeoutFunc nil Set error timeout function for PHOS which will be called when timeout error happened WithErrDoneFunc nil Set err done function for PHOS which will be called when context done happened ","date":"2023-05-05","objectID":"/phos/:6:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"Summary The above is an introduction to PHOS, a Golang channel extension with internal handlers and diversified options. It is hoped that it can provide you with some help or ideas for your development. If there are any mistakes or issues, please feel free to leave a comment or send a private message. The next article will elaborate on the design and implementation of PHOS. If you are interested in PHOS, please give it a Star on GitHub. ","date":"2023-05-05","objectID":"/phos/:7:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":["BINARY WEB ECO"],"content":"Reference List https://github.com/B1NARY-GR0UP/phos ","date":"2023-05-05","objectID":"/phos/:8:0","tags":["go","opensource","programming"],"title":"PHOS: A Go channel extension with internal handlers","uri":"/phos/"},{"categories":null,"content":"111 About Me ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"222 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"333 444 555 666 ","date":"0001-01-01","objectID":"/about/:1:1","tags":null,"title":"","uri":"/about/"}]