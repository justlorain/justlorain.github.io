[{"categories":["BINARY WEB ECO"],"content":"简介 如标题所示，DREAMEMO 是一个模块化，高扩展性，开箱即用的分布式缓存，参考了 groupcache 的实现，并对其重新进行架构，具体模块分化如下： 主要模块将在设计模块进行具体介绍。 ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:1:0","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"快速开始 ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:2:0","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"安装 执行以下命令安装 DREAMEMO： go get github.com/B1NARY-GR0UP/dreamemo ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:2:1","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"以单节点模式运行 DREAMEMO 提供了使用默认配置的以 Standalone 模式运行的函数 dream.StandAlone，用户只需配置好对应数据源的 source.Getter 即可，使用示例如下： package main import ( \"context\" \"fmt\" \"net/http\" \"github.com/B1NARY-GR0UP/dreamemo/common/constant\" \"github.com/B1NARY-GR0UP/dreamemo/dream\" \"github.com/B1NARY-GR0UP/dreamemo/guidance\" \"github.com/B1NARY-GR0UP/dreamemo/source\" log \"github.com/B1NARY-GR0UP/inquisitor/core\" \"github.com/B1NARY-GR0UP/piano/core\" \"github.com/B1NARY-GR0UP/piano/core/bin\" ) var db = map[string]string{ \"binary\": \"dreamemo\", \"hello\": \"world\", \"ping\": \"pong\", } func getFromDB(_ context.Context, key string) ([]byte, error) { log.Info(\"Get from DB\") if v, ok := db[key]; ok { return []byte(v), nil } return nil, fmt.Errorf(\"key %v is not exist\", key) } // go run . // curl localhost:8080/hello?key=ping func main() { dream.StandAlone(source.GetterFunc(getFromDB)) p := bin.Default(core.WithHostAddr(\":8080\")) p.GET(\"/hello\", func(ctx context.Context, pk *core.PianoKey) { key := pk.Query(\"key\") g := guidance.GetGroup(constant.DefaultGroupName) value, _ := g.Get(ctx, key) pk.JSON(http.StatusOK, core.M{ key: value.String(), }) }) p.Play() } 这里以 map 的形式模拟了数据库数据源，并使用 PIANO HTTP 框架作为前端服务器，用户可以替换成其他 HTTP 框架例如 Hertz, Gin 等，通过 go run . 启动服务，接下来只需要访问对应 URL 即可获取 key 对应的值。 go run . curl localhost:8080/hello?key=ping ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:2:2","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"以集群模式运行 DREAMEMO 同样提供了使用默认配置的以 Cluster 模式运行的函数 dream.Cluster ，用户只需配置好对应集群节点的地址以及数据源即可，使用示例如下： package main import ( \"context\" \"fmt\" \"net/http\" \"github.com/B1NARY-GR0UP/dreamemo/common/constant\" \"github.com/B1NARY-GR0UP/dreamemo/common/util\" \"github.com/B1NARY-GR0UP/dreamemo/dream\" \"github.com/B1NARY-GR0UP/dreamemo/guidance\" \"github.com/B1NARY-GR0UP/dreamemo/source\" log \"github.com/B1NARY-GR0UP/inquisitor/core\" \"github.com/B1NARY-GR0UP/piano/core\" \"github.com/B1NARY-GR0UP/piano/core/bin\" ) var db = map[string]string{ \"binary\": \"dreamemo\", \"hello\": \"world\", \"ping\": \"pong\", } func getFromDB(_ context.Context, key string) ([]byte, error) { log.Info(\"Get from DB\") if v, ok := db[key]; ok { return []byte(v), nil } return nil, fmt.Errorf(\"key %v is not exist\", key) } // go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api // go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 // go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 // curl localhost:8080/hello?key=ping func main() { addrs, api := util.ParseFlags() e := dream.Cluster(source.GetterFunc(getFromDB), addrs...) if api { go func() { p := bin.Default(core.WithHostAddr(\":8080\")) p.GET(\"/hello\", func(ctx context.Context, pk *core.PianoKey) { key := pk.Query(\"key\") g := guidance.GetGroup(constant.DefaultGroupName) value, _ := g.Get(ctx, key) pk.JSON(http.StatusOK, core.M{ key: value.String(), }) }) p.Play() }() } e.Run() } 这里同样以 map 模拟数据库数据源，并在 localhost:7246，localhost:7247 和 localhost:7248 配置了 3 个缓存节点，在 8080 端口配置了前端服务器，通过以下命令进行运行并访问对应 URL 即可获取 key 对应的值： go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 curl localhost:8080/hello?key=ping ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:2:3","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"自定义装配 前面介绍了使用 DREAMEMO 配置好的 dream.StandAlone 和 dream.Cluster 函数进行运行，这里将介绍以更加客制化的方式进行装配运行。 配置引擎 这里配置了引擎，util.ParseFlags 是提供的用于解析 flag 参数的工具方法，我们通过 app.WithHostAddr 配置引擎的监听地址并通过 app.WithThrift0 配置引擎使用 Thrift 作为序列化协议，并对其他节点进行注册。 addrs, api := util.ParseFlags() e := server.NewEngine(app.WithHostAddr(addrs[0]), app.WithThrift0()) e.RegisterInstances(addrs...) 配置缓存淘汰策略 配置 LFU 策略 l := lfu.NewLFUCore() m := memo.NewMemo(l) 配置缓存组 这里通过 guidance.WithGroupName 配置缓存组名，通过 guidance.WithThrift1 配置使用 Thrift 作为序列化协议，注意这里需要和引擎保持一致，最后配置数据源 source.Getter guidance.NewGroup(m, e, guidance.WithGroupName(\"hello\"), guidance.WithThrift1(), guidance.WithGetter(source.GetterFunc(getFromDB))) 完整代码如下： package main import ( \"context\" \"fmt\" \"net/http\" \"github.com/B1NARY-GR0UP/dreamemo/app\" \"github.com/B1NARY-GR0UP/dreamemo/app/server\" \"github.com/B1NARY-GR0UP/dreamemo/common/util\" \"github.com/B1NARY-GR0UP/dreamemo/guidance\" \"github.com/B1NARY-GR0UP/dreamemo/memo\" \"github.com/B1NARY-GR0UP/dreamemo/source\" \"github.com/B1NARY-GR0UP/dreamemo/strategy/eliminate/lfu\" log \"github.com/B1NARY-GR0UP/inquisitor/core\" \"github.com/B1NARY-GR0UP/piano/core\" \"github.com/B1NARY-GR0UP/piano/core/bin\" ) var db = map[string]string{ \"binary\": \"dreamemo\", \"hello\": \"world\", \"ping\": \"pong\", } func getFromDB(_ context.Context, key string) ([]byte, error) { log.Info(\"Get from DB\") if v, ok := db[key]; ok { return []byte(v), nil } return nil, fmt.Errorf(\"key %v is not exist\", key) } // go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api // go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 // go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 // curl localhost:8080/hello?key=ping func main() { addrs, api := util.ParseFlags() e := server.NewEngine(app.WithHostAddr(addrs[0]), app.WithThrift0()) e.RegisterInstances(addrs...) l := lfu.NewLFUCore() m := memo.NewMemo(l) guidance.NewGroup(m, e, guidance.WithGroupName(\"hello\"), guidance.WithThrift1(), guidance.WithGetter(source.GetterFunc(getFromDB))) if api { go func() { p := bin.Default(core.WithHostAddr(\":8080\")) p.GET(\"/hello\", func(ctx context.Context, pk *core.PianoKey) { key := pk.Query(\"key\") g := guidance.GetGroup(\"hello\") value, _ := g.Get(ctx, key) pk.JSON(http.StatusOK, core.M{ key: value.String(), }) }) p.Play() }() } e.Run() } 使用以下命令运行并获取缓存： go run . --addrs=http://localhost:7246,http://localhost:7247,http://localhost:7248 --api go run . --addrs=http://localhost:7247,http://localhost:7248,http://localhost:7246 go run . --addrs=http://localhost:7248,http://localhost:7246,http://localhost:7247 curl localhost:8080/hello?key=ping ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:2:4","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"设计 ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:3:0","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"缓存淘汰 在缓存淘汰策略方面，DREAMEMO 支持 LRU 和 LFU 两种缓存淘汰算法，用户可以自行进行选择装配： 使用 LRU c := lru.NewLRUCore() 使用 LFU c := lfu.NewLFUCore() 同时 DREAMEMO 也提供了接口供用户扩展其他的淘汰策略，只需实现接口并将对象传入 memo.NewMemo 即可，接口如下： type ICore interface { Add(Key, Value) Get(Key) (Value, bool) Remove(Key) Clear() Name() string } ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:3:1","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"序列化 DREAMEMO 支持 Thrift 和 Protobuf 两种序列化协议，默认使用 Protobuf 协议，如需使用 Thrift 协议，用户只需要在同时在配置引擎和缓存组处开启配置即可： e := server.NewEngine(app.WithThrift0()) // engine guidance.NewGroup(m, e, guidance.WithThrift1()) // group ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:3:2","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"数据源 DREAMEMO 默认提供了以 Redis 作为数据源的配置： s := redis.NewSource() 同时也提供了接口供用户配置更多自己的数据源： type Getter interface { Get(ctx context.Context, key string) ([]byte, error) } ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:3:3","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"一致性哈希 DREAMEMO 和 groupcache 一样使用一致性哈希进行分布式节点选择，同时也提供了接口以供配置更多的策略。 ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:3:4","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"TODO DREAMEMO 仍非常稚嫩，存在很多可供修改的点，之后将会提供更多可供的节点选择算法以及快速配置工具。 ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:4:0","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"小结 以上就是分布式缓存 DREAMEMO 的介绍，希望可以给你带来一些帮助，项目地址在这里，欢迎 Star。如果有疑问可以在评论区指出，提 Issue 或者私信，以上。 ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:5:0","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"参考列表 https://github.com/B1NARY-GR0UP/dreamemo https://github.com/B1NARY-GR0UP/piano https://github.com/golang/groupcache https://github.com/geektutu/7days-golang ","date":"2023-05-05","objectID":"/zh-cn/dreamemo/:6:0","tags":["go","opensource","programming"],"title":"DREAMEMO: 一个模块化，高扩展性，开箱即用的分布式缓存","uri":"/zh-cn/dreamemo/"},{"categories":["BINARY WEB ECO"],"content":"前言 Channel 是 Golang 一个非常重要的语言特性，熟练的使用 channel 可以让我们在并发编程中如鱼得水，本文将介绍一个基于 Golang 原生 channel 实现的 channel 扩展 PHOS，通过使用 PHOS 可以让我们对传入 channel 的数据进行特定的处理，同时 PHOS 也具有非常丰富的配置选项，我们可以基于不同需求对 PHOS 进行定制使用。 ","date":"2023-05-05","objectID":"/zh-cn/phos/:1:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"什么是 PHOS ? PHOS 是一个具有内置处理器和多样化选项的 Golang Channel 扩展。 ","date":"2023-05-05","objectID":"/zh-cn/phos/:2:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"安装 注意：在安装之前，确保你使用的 Golang 版本支持泛型（Go \u003e= 1.18） 执行以下命令安装 PHOS： go get github.com/B1NARY-GR0UP/phos ","date":"2023-05-05","objectID":"/zh-cn/phos/:3:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"快速开始 在以下示例中，我们首先定义了一个我们自己的 PHOS 内置处理器，然后通过创建一个 PHOS 实例并将这个处理器加入到 PHOS 的处理器链中，最后我们通过传入一个数据即可得到经过处理器处理后的结果并将其打印出来，即 BINARY += -PHOS =\u003e BINARY-PHOS。 package main import ( \"context\" \"fmt\" \"github.com/B1NARY-GR0UP/phos\" ) func hello(_ context.Context, data string) (string, error) { return data + \"-PHOS\", nil } func main() { ph := phos.New[string]() defer close(ph.In) // Note: You should decide which handlers you want to use once, // otherwise multiple changes to the Handlers slice may cause data race problem ph.Handlers = append(ph.Handlers, hello) ph.In \u003c- \"BINARY\" res := \u003c-ph.Out fmt.Println(res.Data) } ","date":"2023-05-05","objectID":"/zh-cn/phos/:4:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"使用帮助 ","date":"2023-05-05","objectID":"/zh-cn/phos/:5:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"关于创建 PHOS 是基于泛型的，我们在通过 phos.New 方法来创建实例时即可通过设置泛型来对特定类型的数据进行处理。 并且在创建实例时你不需要像使用普通的 Channel 那样指定 Channel 的缓冲区大小，你可以假定 PHOS 的缓冲区没有限制。 同时 PHOS 也支持了许多的自定义选项，我们可以在通过 phos.New 创建实例时以选项嵌入的模式进行追加，例如： ph := phos.New[string](phos.WithZero(), phos.WithTimeout(time.Second*5)) 更多支持的选项将在之后的章节以表格的形式列出。 ","date":"2023-05-05","objectID":"/zh-cn/phos/:5:1","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"关于输入输出 PHOS 通过一个只读和一个只写的 Channel 来实现数据的输入输出。 输入 在通过 phos.New 创建出一个实例后，通过 In 这个公开的只写 Channel 即可向 PHOS 中传入数据，例如在快速开始中我们向 In 中传入了一个字符串，需要注意的是传入数据的类型应该与你创建实例时所使用的泛型类型保持一致，并且正如我们前面提到的，你可以接近无限制的向 PHOS 中传入数据而不要指定缓冲区的大小： ph.In \u003c- \"BINARY\" ph.In \u003c- \"Hello\" ph.In \u003c- \"Foo\" ... 输出 我们同样可以通过 Out 这个公开的只读 Channel 来读取经过 PHOS 处理后的数据，需要注意的是，Out 输出的值被封装为 Result 类型： Data 字段是处理后的结果，其类型也与实例的泛型类型相匹配； OK 字段与我们平时从 Channel 中获取数据的第二个可选变量用法一致，可以用来判断是否可以从 Channel 读取到数据； 注意：在使用 PHOS 时你不应该再使用 Out Channel 的第二个返回值而是使用 Result 的 OK 字段，因为 Out Channel 的第二个返回值将一直为 true，对其错误的使用将导致 bug。 Err 字段会提示一些在使用 PHOS 时会出现的异常，例如超时异常，内部处理器处理异常，这将在下文进行阐述。 // Result PHOS output result type Result[T any] struct { Data T // Note: You should use the OK of Result rather than the second return value of PHOS Out channel OK bool Err *Error } ","date":"2023-05-05","objectID":"/zh-cn/phos/:5:2","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"关于内置处理器 内置处理器是 PHOS 最重要的特性之一，通过设置一个或多个内置处理器，PHOS 将按照顺序对每一个输入的数据依次执行所有的内置处理器，并且我们可以通过返回值的形式将前一个处理器处理后的结果传入下一个处理器之中继续进行处理。 一个合法的处理器函数签名如下： func(ctx context.Context, data T) (T, error) 我们可以通过对 PHOS 的 Handlers 公开切片字段追加我们自定义的处理器来构造一个处理器链，例如如下我们构造了一个具有三个处理器的处理器链，每一个处理器将对传入的数据进行一次加一操作，最终每个传入的数据都会在加三（+1 * 3）后返回给我们： package main import ( \"context\" \"fmt\" \"github.com/B1NARY-GR0UP/phos\" ) func plusOne(_ context.Context, data int) (int, error) { return data + 1, nil } func main() { ph := phos.New[int]() defer close(ph.In) ph.Handlers = append(ph.Handlers, plusOne, plusOne, plusOne) ph.In \u003c- 1 ph.In \u003c- 2 ph.In \u003c- 3 res1 := \u003c-ph.Out res2 := \u003c-ph.Out res3 := \u003c-ph.Out fmt.Println(res1.Data) // 4 fmt.Println(res2.Data) // 5 fmt.Println(res3.Data) // 6 } ","date":"2023-05-05","objectID":"/zh-cn/phos/:5:3","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"关于异常处理 PHOS 对异常进行了包装分类，主要分为三种类型： const ( _ ErrorType = iota TimeoutErr HandleErr CtxErr ) 超时异常 超时机制是 PHOS 的一个核心特性，它规定了内置处理器链对每个数据的最大处理时间，如果超时则会触发超时异常，如果不配置超时异常处理器选项则会输出对应输入的初始数据，并在 Result 的 Err 字段显示超时异常；如果配置了超时异常处理器，则会输出经过超时异常处理器处理后的数据。 内置处理器异常 如果在执行内置处理器链中的任何一个处理器发生了异常，则处理器链终止，根据是否配置了内置处理器异常处理器来决定返回的数据是最后处理过的数据还是经过异常处理器处理后的数据，同样异常会配置在 Result 的 Err 字段。 上下文异常 上下文异常发生在配置了 WithContext 选项后并触发后的情况，这时数据处理会立刻终止并根据是否配置了 ErrDoneFunc 返回最开始的数据还是经过异常处理器处理后的数据，同样会将异常信息展示在 Result 的 Err 字段。 零值选项 开启零值选项后，只要发生以上任何一种异常，都将返回对应数据类型的零值，这会对配置的超时异常处理器和内置处理器异常处理器的数据处理结果进行覆盖。 ","date":"2023-05-05","objectID":"/zh-cn/phos/:5:4","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"配置 选项 默认值 描述 WithContext context.Background() 设置 PHOS 的 context WithZero false 开启后出现异常时将返回对应类型的零值 WithTimeout time.Second * 3 设置内置处理器链的超时时间 WithErrHandleFunc nil 设置出现内置处理器异常时的异常处理函数 WithErrTimeoutFunc nil 设置出现超时异常时的异常处理函数 WithErrDoneFunc nil 设置出现上下文 Done 时的异常处理函数 ","date":"2023-05-05","objectID":"/zh-cn/phos/:6:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"总结 以上就是对 PHOS，一个具有内置处理器和多样化选项的 Golang Channel 扩展的介绍，希望他可以为你的开发提供帮助或者为你提供一些思路，如果哪里写错了或者有问题欢迎评论或者私聊指出ww 下一篇文章将对 PHOS 的设计与实现思路进行阐述，如果你对 PHOS 感兴趣，欢迎 Star !!! ","date":"2023-05-05","objectID":"/zh-cn/phos/:7:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"后记 由于初版的 PHOS 被发现在某些场景下会出现 data race 问题，详见 这个 issue ，目前已经修复，并且由于对部分 API 进行了修改发布了新的中版本。主要调整的 API 为用户添加处理器 Handler 部分的方式，新的版本提供了 Append，Remove，Len 等方法而禁止用户对 PHOS 的 Handler 切片直接进行修改。整体使用方式基本不变，详情可以参考 PHOS Readme。 ","date":"2023-05-05","objectID":"/zh-cn/phos/:8:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":["BINARY WEB ECO"],"content":"参考列表 https://github.com/B1NARY-GR0UP/phos ","date":"2023-05-05","objectID":"/zh-cn/phos/:9:0","tags":["go","opensource","programming"],"title":"PHOS: 一个具有内置处理器的 Go channel 扩展","uri":"/zh-cn/phos/"},{"categories":null,"content":"111 关于我 ","date":"0001-01-01","objectID":"/zh-cn/about/:0:0","tags":null,"title":"","uri":"/zh-cn/about/"},{"categories":null,"content":"222 ","date":"0001-01-01","objectID":"/zh-cn/about/:1:0","tags":null,"title":"","uri":"/zh-cn/about/"},{"categories":null,"content":"333 444 555 666 ","date":"0001-01-01","objectID":"/zh-cn/about/:1:1","tags":null,"title":"","uri":"/zh-cn/about/"}]